<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Doom-Style Raycasting Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #000;
            touch-action: none;
        }
        
        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #ui {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0000;
            font-size: 24px;
            text-shadow: 2px 2px 4px #000;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border: 3px solid #ff0000;
            z-index: 100;
            pointer-events: none;
        }
        
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #ff0000;
            z-index: 100;
            pointer-events: none;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 50;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: #00ff00;
            box-shadow: 0 0 5px #00ff00;
        }
        
        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #crosshair::after {
            height: 2px;
            width: 100%;
            top: 50%;
            transform: translateY(-50%);
        }
        
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #000 0%, #300 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ff0000;
            z-index: 200;
        }
        
        #startScreen h1 {
            font-size: 72px;
            margin: 20px;
            text-shadow: 4px 4px 8px #000;
            animation: pulse 2s infinite;
        }
        
        #startScreen button {
            font-family: 'Courier New', monospace;
            font-size: 32px;
            padding: 20px 40px;
            background: #ff0000;
            color: #000;
            border: none;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 20px #ff0000;
            transition: all 0.3s;
        }
        
        #startScreen button:hover {
            background: #fff;
            transform: scale(1.1);
        }
        
        #instructions {
            margin-top: 30px;
            font-size: 18px;
            text-align: center;
            color: #aaa;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ff0000;
            z-index: 200;
        }
        
        #gameOver h2 {
            font-size: 64px;
            margin: 20px;
        }
        
        #gameOver button {
            font-family: 'Courier New', monospace;
            font-size: 24px;
            padding: 15px 30px;
            background: #ff0000;
            color: #000;
            border: none;
            cursor: pointer;
            margin-top: 20px;
        }
        
        /* Touch Controls */
        #touchControls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 250px;
            display: none;
            z-index: 90;
            pointer-events: auto;
            touch-action: none;
        }
        
        #joystick {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
        }
        
        #joystickKnob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            background: rgba(255, 0, 0, 0.5);
            border: 3px solid rgba(255, 0, 0, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        
        #shootButton {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 100px;
            height: 100px;
            background: rgba(255, 0, 0, 0.3);
            border: 3px solid rgba(255, 0, 0, 0.6);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            color: #ff0000;
            pointer-events: auto;
            user-select: none;
            touch-action: none;
        }
        
        #shootButton:active {
            background: rgba(255, 0, 0, 0.6);
        }
        
        #lookPad {
            position: absolute;
            bottom: 30px;
            right: 150px;
            width: 120px;
            height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.5);
            user-select: none;
            touch-action: none;
        }
        
        @media (max-width: 768px) {
            #touchControls {
                display: block;
            }
            
            #ui {
                font-size: 18px;
                padding: 10px 20px;
                bottom: 190px;
            }
            
            #minimap {
                width: 150px;
                height: 150px;
                top: 10px;
                right: 10px;
            }
        }

        @media (pointer: coarse) {
            #touchControls {
                display: block;
            }
            
            #ui {
                bottom: 190px;
            }
            
            #minimap {
                width: 150px;
                height: 150px;
                top: 10px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>DOOM-STYLE GAME</h1>
        <button id="startButton">START GAME</button>
        <div id="instructions">
            <p>WASD/Touch - Move | Mouse/Touch - Look | Click/Tap - Shoot</p>
            <p>Kill all enemies to win!</p>
        </div>
    </div>
    
    <div id="gameOver">
        <h2 id="gameOverText">GAME OVER</h2>
        <p id="finalScore"></p>
        <button id="restartButton">RESTART</button>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    <canvas id="minimap"></canvas>
    
    <div id="crosshair"></div>
    <div id="ui">
        <span>HEALTH: <span id="health">100</span></span> | 
        <span>AMMO: <span id="ammo">âˆž</span></span> | 
        <span>ENEMIES: <span id="enemies">0</span></span>
    </div>
    
    <!-- Touch Controls -->
    <div id="touchControls">
        <div id="joystick">
            <div id="joystickKnob"></div>
        </div>
        <div id="lookPad">LOOK</div>
        <div id="shootButton">ðŸ”«</div>
    </div>

    <script>
        // Game canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Minimap setup
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = 200;
        minimapCanvas.height = 200;

        // Game constants
        const TILE_SIZE = 64;
        const FOV = Math.PI / 3;
        const HALF_FOV = FOV / 2;
        const NUM_RAYS = Math.min(640, canvas.width); // Limit rays for performance
        const MAX_DEPTH = 800;
        const DELTA_ANGLE = FOV / NUM_RAYS;

        // Game state
        const gameState = {
            health: 100,
            score: 0,
            enemiesKilled: 0,
            totalEnemies: 5,
            isPlaying: false,
            pointerLocked: false
        };

        // Player
        const player = {
            x: 3.5 * TILE_SIZE,
            y: 3.5 * TILE_SIZE,
            angle: 0,
            speed: 2,
            rotSpeed: 0.03
        };

        // Touch controls state
        const touchState = {
            joystick: { active: false, deltaX: 0, deltaY: 0 },
            look: { active: false, startX: 0, startY: 0 }
        };

        // Map (1 = wall, 0 = empty, 2 = enemy spawn)
        const map = [
            [1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,1,0,0,2,0,1],
            [1,0,0,1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1,1,0,1],
            [1,0,2,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,2,1],
            [1,0,0,2,0,0,2,0,0,1],
            [1,1,1,1,1,1,1,1,1,1]
        ];

        // Enemy class
        class Enemy {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.health = 3;
                this.speed = 0.5;
                this.lastShot = 0;
                this.isAlive = true;
                this.size = 32;
                this.color = '#ff0000';
            }
            
            update(playerX, playerY) {
                if (!this.isAlive) return;
                
                // Move towards player
                const dx = playerX - this.x;
                const dy = playerY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > this.size) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
                
                // Attack player if close
                if (dist < 100 && Date.now() - this.lastShot > 1500) {
                    this.attack();
                    this.lastShot = Date.now();
                }
            }
            
            attack() {
                gameState.health -= 10;
                updateUI();
                
                if (gameState.health <= 0) {
                    endGame(false);
                }
            }
            
            hit() {
                this.health--;
                if (this.health <= 0) {
                    this.die();
                }
            }
            
            die() {
                this.isAlive = false;
                gameState.enemiesKilled++;
                gameState.score += 100;
                updateUI();
                
                if (gameState.enemiesKilled >= gameState.totalEnemies) {
                    setTimeout(() => endGame(true), 1000);
                }
            }
            
            getAngle(playerX, playerY) {
                return Math.atan2(this.y - playerY, this.x - playerX);
            }
            
            getDistance(playerX, playerY) {
                const dx = this.x - playerX;
                const dy = this.y - playerY;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }

        // Create enemies and store spawn positions
        const enemies = [];
        const enemySpawnPoints = [];
        for (let y = 0; y < map.length; y++) {
            for (let x = 0; x < map[y].length; x++) {
                if (map[y][x] === 2) {
                    const spawnX = x * TILE_SIZE + TILE_SIZE/2;
                    const spawnY = y * TILE_SIZE + TILE_SIZE/2;
                    enemySpawnPoints.push({ x: spawnX, y: spawnY });
                    enemies.push(new Enemy(spawnX, spawnY));
                    map[y][x] = 0; // Clear spawn point
                }
            }
        }

        // Input handling
        const keys = {};
        let mouseX = 0;

        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        // Pointer lock
        canvas.addEventListener('click', () => {
            if (gameState.isPlaying && !gameState.pointerLocked) {
                canvas.requestPointerLock();
            }
            if (gameState.isPlaying && gameState.pointerLocked) {
                shoot();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            gameState.pointerLocked = document.pointerLockElement === canvas;
        });

        document.addEventListener('mousemove', (e) => {
            if (gameState.pointerLocked) {
                player.angle += e.movementX * 0.002;
            }
        });

        // Collision detection
        function checkCollision(x, y) {
            const mapX = Math.floor(x / TILE_SIZE);
            const mapY = Math.floor(y / TILE_SIZE);
            
            if (mapY < 0 || mapY >= map.length || mapX < 0 || mapX >= map[0].length) {
                return true;
            }
            
            return map[mapY][mapX] === 1;
        }

        // Raycasting
        function castRays() {
            const rays = [];
            
            for (let i = 0; i < NUM_RAYS; i++) {
                const rayAngle = player.angle - HALF_FOV + i * DELTA_ANGLE;
                
                let depth = 0;
                let hit = false;
                
                const sin = Math.sin(rayAngle);
                const cos = Math.cos(rayAngle);
                
                while (!hit && depth < MAX_DEPTH) {
                    depth += 1;
                    
                    const targetX = player.x + cos * depth;
                    const targetY = player.y + sin * depth;
                    
                    if (checkCollision(targetX, targetY)) {
                        hit = true;
                    }
                }
                
                // Fix fish-eye effect
                const fixedDepth = depth * Math.cos(player.angle - rayAngle);
                
                rays.push({
                    angle: rayAngle,
                    depth: fixedDepth,
                    hit: hit
                });
            }
            
            return rays;
        }

        // Render scene
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw ceiling
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height / 2);
            
            // Draw floor
            ctx.fillStyle = '#0d0d0d';
            ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);
            
            // Cast rays and draw walls
            const rays = castRays();
            
            for (let i = 0; i < rays.length; i++) {
                const ray = rays[i];
                
                if (ray.hit) {
                    const wallHeight = Math.min(canvas.height, (TILE_SIZE * canvas.height) / ray.depth);
                    
                    // Calculate wall color based on depth (darker when farther)
                    const darkness = Math.max(0, 1 - ray.depth / MAX_DEPTH);
                    const baseColor = 100;
                    const colorValue = Math.floor(baseColor * darkness + 20);
                    
                    const columnWidth = canvas.width / NUM_RAYS;
                    ctx.fillStyle = `rgb(${colorValue}, ${colorValue * 0.3}, ${colorValue * 0.3})`;
                    ctx.fillRect(i * columnWidth, (canvas.height - wallHeight) / 2, Math.ceil(columnWidth), wallHeight);
                }
            }
            
            // Draw enemies (sprites)
            enemies.forEach(enemy => {
                if (!enemy.isAlive) return;
                
                const enemyAngle = enemy.getAngle(player.x, player.y);
                const enemyDist = enemy.getDistance(player.x, player.y);
                
                // Calculate angle difference
                let angleDiff = enemyAngle - player.angle;
                
                // Normalize angle
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                // Only draw if in FOV
                if (Math.abs(angleDiff) < HALF_FOV + 0.5) {
                    // Clamp distance to prevent sprites from becoming too large when very close
                    const clampedDist = Math.max(enemyDist, TILE_SIZE * 1.5);
                    const spriteHeight = Math.min(canvas.height * 0.3, (TILE_SIZE * canvas.height) / clampedDist);
                    const spriteWidth = spriteHeight;
                    
                    const spriteX = (angleDiff + HALF_FOV) / FOV * canvas.width - spriteWidth / 2;
                    const spriteY = (canvas.height - spriteHeight) / 2;
                    
                    // Draw enemy sprite (simple colored rectangle with details)
                    const darkness = Math.max(0.2, 1 - enemyDist / MAX_DEPTH);
                    
                    // Body
                    ctx.fillStyle = `rgba(255, 0, 0, ${darkness})`;
                    ctx.fillRect(spriteX, spriteY, spriteWidth, spriteHeight);
                    
                    // Eyes
                    ctx.fillStyle = `rgba(255, 255, 0, ${darkness})`;
                    const eyeSize = spriteWidth / 6;
                    ctx.fillRect(spriteX + spriteWidth * 0.25 - eyeSize/2, spriteY + spriteHeight * 0.3, eyeSize, eyeSize);
                    ctx.fillRect(spriteX + spriteWidth * 0.75 - eyeSize/2, spriteY + spriteHeight * 0.3, eyeSize, eyeSize);
                    
                    // Mouth
                    ctx.fillRect(spriteX + spriteWidth * 0.3, spriteY + spriteHeight * 0.6, spriteWidth * 0.4, spriteHeight * 0.1);
                }
            });
        }

        // Shoot function
        function shoot() {
            // Find enemy in crosshair
            let closestEnemy = null;
            let closestDist = Infinity;
            
            enemies.forEach(enemy => {
                if (!enemy.isAlive) return;
                
                const enemyAngle = enemy.getAngle(player.x, player.y);
                const enemyDist = enemy.getDistance(player.x, player.y);
                
                let angleDiff = enemyAngle - player.angle;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                // Check if aiming at enemy (within small angle)
                if (Math.abs(angleDiff) < 0.1 && enemyDist < closestDist) {
                    closestEnemy = enemy;
                    closestDist = enemyDist;
                }
            });
            
            if (closestEnemy && closestDist < 400) {
                closestEnemy.hit();
                
                // Visual feedback
                ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // Update game state
        function update() {
            if (!gameState.isPlaying) return;
            
            // Player movement
            const moveSpeed = player.speed;
            let newX = player.x;
            let newY = player.y;
            
            if (keys['KeyW']) {
                newX += Math.cos(player.angle) * moveSpeed;
                newY += Math.sin(player.angle) * moveSpeed;
            }
            if (keys['KeyS']) {
                newX -= Math.cos(player.angle) * moveSpeed;
                newY -= Math.sin(player.angle) * moveSpeed;
            }
            if (keys['KeyA']) {
                newX += Math.cos(player.angle - Math.PI/2) * moveSpeed;
                newY += Math.sin(player.angle - Math.PI/2) * moveSpeed;
            }
            if (keys['KeyD']) {
                newX += Math.cos(player.angle + Math.PI/2) * moveSpeed;
                newY += Math.sin(player.angle + Math.PI/2) * moveSpeed;
            }
            
            // Check collision before moving
            if (!checkCollision(newX, player.y)) {
                player.x = newX;
            }
            if (!checkCollision(player.x, newY)) {
                player.y = newY;
            }
            
            // Apply touch joystick movement
            if (touchState.joystick.active) {
                const moveX = Math.cos(player.angle) * touchState.joystick.deltaY * -moveSpeed;
                const moveY = Math.sin(player.angle) * touchState.joystick.deltaY * -moveSpeed;
                const strafeX = Math.cos(player.angle + Math.PI/2) * touchState.joystick.deltaX * moveSpeed;
                const strafeY = Math.sin(player.angle + Math.PI/2) * touchState.joystick.deltaX * moveSpeed;
                
                let touchNewX = player.x + moveX + strafeX;
                let touchNewY = player.y + moveY + strafeY;
                
                if (!checkCollision(touchNewX, player.y)) {
                    player.x = touchNewX;
                }
                if (!checkCollision(player.x, touchNewY)) {
                    player.y = touchNewY;
                }
            }
            
            // Update enemies
            enemies.forEach(enemy => enemy.update(player.x, player.y));
        }

        // UI updates
        function updateUI() {
            document.getElementById('health').textContent = Math.max(0, gameState.health);
            document.getElementById('enemies').textContent = (gameState.totalEnemies - gameState.enemiesKilled);
        }

        // Draw minimap
        function drawMinimap() {
            const mapSize = map.length;
            const cellSize = minimapCanvas.width / mapSize;
            
            // Clear minimap
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            // Draw map tiles
            for (let row = 0; row < mapSize; row++) {
                for (let col = 0; col < mapSize; col++) {
                    const x = col * cellSize;
                    const y = row * cellSize;
                    
                    if (map[row][col] === 1) {
                        // Wall
                        minimapCtx.fillStyle = '#666';
                        minimapCtx.fillRect(x, y, cellSize, cellSize);
                    } else {
                        // Corridor
                        minimapCtx.fillStyle = '#222';
                        minimapCtx.fillRect(x, y, cellSize, cellSize);
                    }
                    
                    // Draw grid
                    minimapCtx.strokeStyle = '#444';
                    minimapCtx.lineWidth = 1;
                    minimapCtx.strokeRect(x, y, cellSize, cellSize);
                }
            }
            
            // Draw enemies
            enemies.forEach(enemy => {
                if (!enemy.isAlive) return;
                
                const enemyMapX = (enemy.x / TILE_SIZE) * cellSize;
                const enemyMapY = (enemy.y / TILE_SIZE) * cellSize;
                
                minimapCtx.fillStyle = '#ff0000';
                minimapCtx.beginPath();
                minimapCtx.arc(enemyMapX, enemyMapY, cellSize * 0.3, 0, Math.PI * 2);
                minimapCtx.fill();
            });
            
            // Draw player
            const playerMapX = (player.x / TILE_SIZE) * cellSize;
            const playerMapY = (player.y / TILE_SIZE) * cellSize;
            
            minimapCtx.fillStyle = '#00ff00';
            minimapCtx.beginPath();
            minimapCtx.arc(playerMapX, playerMapY, cellSize * 0.4, 0, Math.PI * 2);
            minimapCtx.fill();
            
            // Draw player direction
            const directionLength = cellSize * 0.6;
            const endX = playerMapX + Math.cos(player.angle) * directionLength;
            const endY = playerMapY + Math.sin(player.angle) * directionLength;
            
            minimapCtx.strokeStyle = '#00ff00';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(playerMapX, playerMapY);
            minimapCtx.lineTo(endX, endY);
            minimapCtx.stroke();
        }

        // Touch controls setup
        function setupTouchControls() {
            const joystick = document.getElementById('joystick');
            const joystickKnob = document.getElementById('joystickKnob');
            const lookPad = document.getElementById('lookPad');
            const shootButton = document.getElementById('shootButton');
            
            // Joystick for movement
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchState.joystick.active = true;
            });
            
            joystick.addEventListener('touchmove', (e) => {
                if (!touchState.joystick.active) return;
                e.preventDefault();
                
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;
                
                const maxDist = rect.width / 2 - 30;
                const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (dist > maxDist) {
                    deltaX = (deltaX / dist) * maxDist;
                    deltaY = (deltaY / dist) * maxDist;
                }
                
                touchState.joystick.deltaX = deltaX / maxDist;
                touchState.joystick.deltaY = deltaY / maxDist;
                
                joystickKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
            });
            
            joystick.addEventListener('touchend', () => {
                touchState.joystick.active = false;
                touchState.joystick.deltaX = 0;
                touchState.joystick.deltaY = 0;
                joystickKnob.style.transform = 'translate(-50%, -50%)';
            });
            
            // Look pad for camera rotation
            lookPad.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchState.look.active = true;
                touchState.look.startX = e.touches[0].clientX;
                touchState.look.startY = e.touches[0].clientY;
            });
            
            lookPad.addEventListener('touchmove', (e) => {
                if (!touchState.look.active) return;
                e.preventDefault();
                
                const touch = e.touches[0];
                const deltaX = (touch.clientX - touchState.look.startX) * 0.005;
                
                player.angle += deltaX;
                
                touchState.look.startX = touch.clientX;
                touchState.look.startY = touch.clientY;
            });
            
            lookPad.addEventListener('touchend', () => {
                touchState.look.active = false;
            });
            
            // Shoot button
            shootButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState.isPlaying) {
                    shoot();
                }
            });
        }
        
        setupTouchControls();

        // Game over
        function endGame(won) {
            gameState.isPlaying = false;
            document.exitPointerLock();
            
            const gameOverScreen = document.getElementById('gameOver');
            const gameOverText = document.getElementById('gameOverText');
            const finalScore = document.getElementById('finalScore');
            
            if (won) {
                gameOverText.textContent = 'VICTORY!';
                gameOverText.style.color = '#00ff00';
            } else {
                gameOverText.textContent = 'YOU DIED';
                gameOverText.style.color = '#ff0000';
            }
            
            finalScore.textContent = `Score: ${gameState.score} | Enemies Killed: ${gameState.enemiesKilled}/${gameState.totalEnemies}`;
            gameOverScreen.style.display = 'flex';
        }

        // Reset game
        function resetGame() {
            gameState.health = 100;
            gameState.score = 0;
            gameState.enemiesKilled = 0;
            gameState.isPlaying = true;
            
            player.x = 3.5 * TILE_SIZE;
            player.y = 3.5 * TILE_SIZE;
            player.angle = 0;
            
            // Reset enemies at their original spawn points
            enemies.length = 0;
            enemySpawnPoints.forEach(spawn => {
                enemies.push(new Enemy(spawn.x, spawn.y));
            });
            
            gameState.totalEnemies = enemies.length;
            
            updateUI();
            document.getElementById('gameOver').style.display = 'none';
        }

        // Start button
        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('startScreen').style.display = 'none';
            gameState.isPlaying = true;
            canvas.requestPointerLock();
        });

        // Restart button
        document.getElementById('restartButton').addEventListener('click', () => {
            resetGame();
            canvas.requestPointerLock();
        });

        // Game loop
        function gameLoop() {
            update();
            render();
            drawMinimap();
            requestAnimationFrame(gameLoop);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Update minimap canvas size
            if (window.innerWidth <= 768) {
                minimapCanvas.width = 150;
                minimapCanvas.height = 150;
            } else {
                minimapCanvas.width = 200;
                minimapCanvas.height = 200;
            }
        });

        // Initialize
        updateUI();
        gameLoop();
    </script>
</body>
</html>
